---
title: "Will the liberals win the next Canadian federal election: a mutilevel multiple regression analysis on voting in Canada "
author: "GROUP NUMBER 78: Chun Ki Yip, Jiayi Chen, Nicole Zi Xuan Yeung"
date: November 5, 2021
subtitle: STA304 - Assignment 3
output:
  pdf_document: default
---

```{r, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(openintro)
library(tidyverse)
```



## Introduction

Canada has recently undergone a federal election set in motion by Prime Minister Justin Trudeau in hopes of obtaining a majority government. This decision comes under critisism as Canada is in midst of the COVID-19 pandamic. The election ultimately resulted in Justin Trudeau's Liberals staying in power, but failed to obtain a majority government as the Liberals won 160 seats, short of the 170 needed for a majority government [11]. This election also resulted 

From the first federal election in 1867 to the lastest in 2021, the only two goverments that were in power were the Liberals and the Conservatives. [15] In Canada, the electorial system is referred as a "single-member plurality" system [10] which means that the voter only votes for one candidate in their electorial district. The candidate with the highest number of votes wins a seat in the House of Commons and represents the party of that candidate [10]. In total, there are 336 seats in the House of Commons and a party has to win 170 seats in order to secure a majority government otherwise, like Justin Trudeau's government, will only be a minority government if they have the majority of the seats. 

In this report, the objective is to use the General Social Survey data as the "census" data and the data from the 2019 election as the "survey" data to use multi-level regression and post-stratification to predict the overall popular vote of the next Canadian federal election. The signifcance of the study is to help us get a better picture of our future with future governments and prepare for possible policy changes as different governments will have different policies. To answer the objective, **we hypothesize that the Liberals will continue to be in power in the next Canadian election.**

Justin Trudeau's Liberal government has been in power since he was sworn in on November 4, 2015. He was also re-elected during the 2019 and 2021 election.
Even though that his party was re-elected, there were a lot of controversies surrounding the Prime Minister for example, the overall handling of the COVID-19 Pandamic and the decision to call an election during it. This analysis will take in consideration on how these global events and the decisions that the Prime Minister makes will effect the votes for the next federal election.

This report will be divided into 5 sections. The **Introduction**, where we introduce the data, the research question and give context around the problem. The **Data** section, where we summarize the data and any important numerical summaries. We also will explain the cleaning process of the data. The **Methods** section, where we will explain the statistical methods used to analyze the data. We will also explain the post-stratification procedure. The **Results** section, where we showcase the results of the model and the interpretation of the model. Finally the **Conclusion**, where we reiterate the story of the analysis and provide a recap of the research question, methods and results. We will also share any drawbacks or limitation we encountered during the analysis and recommendations for future analysis.
\newpage

## Terminology
In this section, we will introduce and define terminology that will be used throughout the report.

### Census
A study conducted on the entire population. (STA304 Week 2 slides)

### General Social Survey (GSS)
A series of "independent, annual, cross-sectional surveys, each covering one topic in-depth" with the objective to "gather data on social trends in order to monitor changes in the living conditions and well being of Canadians, and to provide information on specific social policy issues."[10]

### Post-stratification

"Using demographics to extrapolate how entire population will vote" (STA304 Week 6). It also allows us to make a good correction of non-probability based sampling. (STA304 Week 6)

### Majority Government

When a party has more than half the seats in the House of Commons, the party is a Majority Government and has control over the House of Commons. [10]

### Minority Government

When a party has less than half the seats in the House of Commons but still has more seats than the other opposing parties, the party will form a minority government. The opposing parties can block bills from passing since the opposing parties have more seats in total than the elected party. [10]


## Data

### Data Collection

The data used in this analysis is taken from two separate sources. 

First, to create our model, data is taken from the 2019 Canadian Election Study, specifically the phone survey component of that study. The Canadian Election Study is a large-scale survey, started 56 years ago, that is distributed every Canadian election year. It's purpose is to increase public knowledge towards Canadians' opinions regarding relevant social, economics, and political events in addition to how these played a factor in the individual's voting decision. Those eligible to participate must be citizens or permanent residents and age 18 or older at the time of survey.    

The 2019 Canadian Election Study - Phone Survey, funded by Social Sciences and Humanities Research Council of Canada (SSHRC), collected data both during and after the election period [10]. Both users with wireless and land-line telephone numbers were contacted. The initial sampling method used for wireless telephone numbers was modified random digit dialing (RDD) [10]. To select respondents corresponding to land-lines for households with more than one eligible voter, the researchers implemented the birthday selection method [10]. This round of surveying spanned from September 10, 2019 to October 20, 2019 [10]. The second round of interviewing began on October 22, 2019 and ended November 21, 2019 [10]. This targeted the time period after the elections had ended [10]. The amount of participants in the second round of phone surveying is not identical to that during the election period because individuals were given the option to participate in the second survey online instead of over the phone [10]. This was accounted for when we cleaned our data, please see the data cleaning section for more details. For both during and post election surveying, the data collection mode used was computer assisted telephone interviewing (CATI), a data capture program that records responses electronically while the interview occurs [10]. Overall, 66% of phone sample was contacted through wireless telephone numbers and 34% through land-line telephone numbers [10]. 

To calculate the post-stratification predictions, data is taken from the 2017 General Social Survey (GSS): Families Cycle 31. GSS, established in 1985, is a regularly conducted telephone survey that aims to understand current living conditions and the well-being of Canadians [8]. It also collects information regarding current social policy issues [8]. The 2017 GSS focuses on family with a target population of all people 15 years of age and older in Canada excluding residents of the Yukon, Northwest Territories, Nunavut and full-time residents of institutions [8]. To collect the data, the country was first split into stratas based on geographic area [8]. The sampling strategy used is a simple random sample without replacement within each strata [8]. Like the CES data, data for the 2017 GSS was collected via CATI [8].
```{r, include = FALSE}

# Importing GSS data

census_data <- read_csv("gss_clean.csv")

# You may need additional chunks, in case you want to include some of the cleaning output.

```
### Data Cleaning

The following will describe the cleaning process of the Canadian Election Study 2019 phone data. 

1. Begin by locating the partially cleaned survey data [9] provided.

2. Convert the continuous age into discrete age groups of the following; under 25, 25-34, 35-44, 45-55, above 55 by changing the value of age from directly taking the value of 2019 minus the value question 2 [9] of the survey to 5 different if else conditional statements that puts the age value which is 2019 minus the question 2 [9] into the above groups if they are within the range of those groups and let the value set to NA if it doesn't fit in any of the groups.

3. Add another column to the survey data named province by using the mutate function [4], and use the condition where the value of province is given by question 4 [9] of the survey. Match each province to the corresponding numerical representation from the survey, and notice that the General Social Survey [8] don't have respondents from Yukon, Northwest Territories, and Nunavut, so these 3 provinces are also eliminated from the survey data conditions. Any respondent's question 4 answers which doesn't fit in the remaining 10 provinces would be set to NA.

4. Add another column to the survey data named the Highest Education by using the mutate function [4], and use if else conditional statements to put the respondents into the following discrete groups by checking at their answers of question 61 [9] of the survey; "Less than highschool diploma", "Completed highschool or equivalent", "Completed technical, community college, CEGEP, College",  "Bachelor's Degree", "Master's Degree or above", and set the value to NA if it doesn't fit in any of these groups.

5. Add another column to the survey data named Household Income Before Tax by using the the mutate function [4], use if else conditional statements to put respondents into the following discrete income levels by checking their answers of question 69 [9]: "Less than 25,000","25,000 to 49,999","50,000 to 74,999", "75,000 to 99,999", "100,000 to  124,999", "125,000 and more", and set the value to NA if the answer doesn't fit in any of these groups. 

6. Add another column to the survey data named Visible Minority by using the mutate function [4], and use if else condition statements to generalize either the respondent answers "Yes" they are a visible minority or "No". The if else statements would check question 66 part A of the survey [9], if the respondent selects that they are Chinese, Indian, or Inuit, Metis, Aboriginal, then they would be grouped into the "Yes" group, while if the respondent selected English, Irish, British, French, Italian, German, Polish, Dutch, Scottish, Ukrainian, French Canadian, or Quebecois, then it would be put into the "No" group, otherwise if the respondent's answers does not match the above, namely if they selected other, then respondent value would be set to NA, because the other section of this question contains too many different possibilities and human errors in entering the answers.

7. Use the select function to show only the 7 variables of interest, namely age, gender, province, visible minority, household income before tax, highest education, and vote liberal. 

8. Lastly omit every respondent or row which contains at least one NA value to omit any respondents that didn't answer the questions properly or doesn't fit in any group which the General Social Survey also surveyed by using the na omit function.

9. Start by locating the partially cleaned data of the General Social Survey Cycle 31 [8] named census data provided.

10. Similarly to the Canadian Election Study data, convert the continuous variable of age into discrete groups by using if else conditional statements are putting them into groups of the following if they fall within the range of the groups; under 25, 25-34, 35-44, 45-55, above 55.

11. Using the mutate function [4], add a column named province, and set the value of province same as the value of province from the General Social Survey [8].

12. Using the mutate function [4], add a column named visible minority and use an if else statement to check each respondent's answer to the visible minority question of the General Social Survey [8], if they selected "Not a visible minority" then put them in the group "No", else put in "Yes".

13. Using the mutate function [4], add a column named Household Income Before Tax and set it equal to the same value as the respondent's answer to family income of the General Social Survey [8].

14. Using the mutate function [4], add a column named Higest Education and use if else conditional statements to put the respondents into the following discrete groups by checking at their answers of education of the General Social Survey [8]; "Less than highschool diploma", "Completed highschool or equivalent", "Completed technical, community college, CEGEP, College",  "Bachelor's Degree", "Master's Degree or above", and set the value to NA if it doesn't fit in any of these groups.

15. Use the mutate function [4] to add a column to the census data named gender, and set it equal to the same values as sex of the General Social Survey [8].

16. Use the select function to select the 6 important variables interested to show only these variables in the cleaned census data, namely the age, gender, province, visible minority, household income before tax, and highest education. 

17. Lastly omit every respondent or row which contains at least one NA value to omit any respondents that didn't answer the questions or had an invalid input.

```{r, include = FALSE}

# Here you can load in and clean the survey data (you may need to do the cleaning in a separate R script). 
# First, if you don't already have it, install the devtools package:
#install.packages("devtools")

# Now use devtools to install the cesR package directly from Github:
#devtools::install_github("hodgettsp/cesR")

# Load it like any other package:
library(cesR)

# There are many different CES datasets, and they have unique codes. 
# See them with the get_cescodes() function:


# Now pick one, let's try ces2019_phone

get_ces("ces2019_phone")

survey_data <- ces2019_phone





```

```{r, include =FALSE}
#### Preamble ####
# Purpose: The purpose of this code is to clean-up the 2017 GSS data obtained 
# from the U of T library. That data is available to U of T students, but it needs 
# to be put into a tidy format before it can be analysed. This code does that.
# The main issue is that the data are released with codes for variables, whereas,
# we want the variable. e.g. sex is 1 or 2, but we want sex is female or male. (This
# sounds trite in that case, but gets more difficult with more involved variables.)
# So we create a dictionary type dataset that has the variable names and their 
# possible values. In that we embed some R code that will do a replacement. We 
# then apply that dataset to the raw dataset. Finally we do all the usual cleaning.
# to the dataset. You will end up with a dataset called gss.csv.
# Authors: Rohan Alexander and Sam Caetano
# Date: 18 May 2021
# License: MIT
# Pre-reqs: You need to have downloaded the data from the library. To do that: 
  ## 1. Go to: http://www.chass.utoronto.ca/
  ## 2. Data centre --> UofT users or http://dc.chass.utoronto.ca/myaccess.html
  ## 3. Click SDA @ CHASS, should redirect to sign in. Sign in.
  ## 4. Continue in English (you're welcome to use the French, but we probably can't
  ## help you too much).
  ## 5. Crtl F GSS, click
  ## 6. Click "Data" on the one you want. We used 2017, but you may want a different 
  ## wave. In particular the General Social Survey on social identity (cycle 27), 
  ## 2013 has some variables on voter participation if you're into that sort of 
  ## thing. You're welcome to pick any year but this code applies to 2017.
  ## 7. Click download
  ## 8. Select CSV data file, data definitions for STATA (gross, but stick with it for now).
  ## 9. Can select all variables by clicking button next to green colored "All". Then continue.
  ## 10. Create the files, download and save

# Check: 
  ## You WILL need to change the raw data name. Search for .csv - line 41
  ## You may need to adjust the filepaths depending on your system. Search for: read_


#### Workspace set-up ####
library(janitor)
library(tidyverse)

# Load the data dictionary and the raw data and correct the variable names
raw_data <- read_csv("AAqCWRgO.csv")
dict <- read_lines("gss_dict.txt", skip = 18) # skip is because of preamble content
# Now we need the labels because these are the actual responses that we need
labels_raw <- read_file("gss_labels.txt")


#### Set-up the dictionary ####
# What we want is a variable name and a variable definition
variable_descriptions <- as_tibble(dict) %>% 
  filter(value!="}") %>% 
  mutate(value = str_replace(value, ".+%[0-9].*f[ ]{2,}", "")) %>% 
  mutate(value = str_remove_all(value, "\"")) %>% 
  rename(variable_description = value) %>% 
  bind_cols(tibble(variable_name = colnames(raw_data)[-1]))
 
# Now we want a variable name and the possible values
labels_raw_tibble <- as_tibble(str_split(labels_raw, ";")[[1]]) %>% 
  filter(row_number()!=1) %>% 
  mutate(value = str_remove(value, "\nlabel define ")) %>% 
  mutate(value = str_replace(value, "[ ]{2,}", "XXX")) %>% 
  mutate(splits = str_split(value, "XXX")) %>% 
  rowwise() %>% 
  mutate(variable_name = splits[1], cases = splits[2]) %>% 
  mutate(cases = str_replace_all(cases, "\n [ ]{2,}", "")) %>%
  select(variable_name, cases) %>% 
  drop_na()

# Now we have the variable name and the different options e.g. age and 0-9, 10-19, etc.
labels_raw_tibble <- labels_raw_tibble %>% 
  mutate(splits = str_split(cases, "[ ]{0,}\"[ ]{0,}"))

# The function sets up the regex (I know, I know, but eh: https://xkcd.com/208/)
add_cw_text <- function(x, y){
  if(!is.na(as.numeric(x))){
    x_new <- paste0(y, "==", x,"~")
  }
  else{
    x_new <- paste0("\"",x,"\",")
  }
  return(x_new)
}

# The function will be in the row, but it'll get the job done
cw_statements <- labels_raw_tibble %>% 
  rowwise() %>% 
  mutate(splits_with_cw_text = list(modify(splits, add_cw_text, y = variable_name))) %>% 
  mutate(cw_statement = paste(splits_with_cw_text, collapse = "")) %>% 
  mutate(cw_statement = paste0("case_when(", cw_statement,"TRUE~\"NA\")")) %>% 
  mutate(cw_statement = str_replace(cw_statement, ",\"\",",",")) %>% 
  select(variable_name, cw_statement)
# So for every variable we now have a case_when() statement that will convert 
# from the number to the actual response.

# Just do some finally cleanup of the regex.
cw_statements <- 
  cw_statements %>% 
  mutate(variable_name = str_remove_all(variable_name, "\\r")) %>% 
  mutate(cw_statement = str_remove_all(cw_statement, "\\r"))


#### Apply that dictionary to the raw data ####
# Pull out a bunch of variables and then apply the case when statement for the categorical variables
gss <- raw_data %>% 
  select(CASEID, 
         agedc, 
         achd_1c, 
         achdmpl, 
         totchdc, 
         acu0c,
         agema1c,
         achb1c,
         rsh_131a,
         arretwk,
         slm_01, 
         sex, 
         brthcan, 
         brthfcan,
         brthmcan,
         brthmacr,
         brthprvc,
         yrarri,
         prv, 
         region, 
         luc_rst, 
         marstat, 
         amb_01, 
         vismin, 
         alndimmg,
         bpr_16, 
         bpr_19,
         ehg3_01b, 
         odr_10, 
         livarr12, 
         dwelc, 
         hsdsizec,
         brthpcan,
         brtpprvc, 
         visminpr,
         rsh_125a, 
         eop_200,
         uhw_16gr,
         lmam_01, 
         acmpryr,
         srh_110,
         srh_115,
         religflg, 
         rlr_110,
         lanhome, 
         lan_01,
         famincg2, 
         ttlincg2, 
         noc1610, 
         cc_20_1,
         cc_30_1,
         ccmoc1c,
         cor_031,
         cor_041,
         cu0rnkc,
         pr_cl,
         chh0014c,
         nochricc,
         grndpa,
         gparliv,
         evermar,
         ma0_220,
         nmarevrc,
         ree_02,
         rsh_131b,
         rto_101,
         rto_110,
         rto_120,
         rtw_300,
         sts_410,
         csp_105,
         csp_110a,
         csp_110b,
         csp_110c,
         csp_110d,
         csp_160,
         fi_110) %>% 
  mutate_at(vars(agedc:fi_110), .funs = funs(ifelse(.>=96, NA, .))) %>% 
  mutate_at(.vars = vars(sex:fi_110),
            .funs = funs(eval(parse(text = cw_statements %>%
                                      filter(variable_name==deparse(substitute(.))) %>%
                                      select(cw_statement) %>%
                                      pull()))))

# Fix the names
gss <- gss %>% 
  clean_names() %>% 
  rename(age = agedc,
         age_first_child = achd_1c,
         age_youngest_child_under_6 = achdmpl,
         total_children = totchdc,
         age_start_relationship = acu0c,
         age_at_first_marriage = agema1c,
         age_at_first_birth = achb1c,
         distance_between_houses = rsh_131a,
         age_youngest_child_returned_work = arretwk,
         feelings_life = slm_01,
         sex = sex,
         place_birth_canada = brthcan,
         place_birth_father = brthfcan,
         place_birth_mother = brthmcan,
         place_birth_macro_region = brthmacr,
         place_birth_province = brthprvc,
         year_arrived_canada = yrarri,
         province = prv,
         region = region,
         pop_center = luc_rst,
         marital_status = marstat,
         aboriginal = amb_01,
         vis_minority = vismin,
         age_immigration = alndimmg,
         landed_immigrant = bpr_16,
         citizenship_status = bpr_19,
         education = ehg3_01b,
         own_rent = odr_10,
         living_arrangement = livarr12,
         hh_type = dwelc,
         hh_size = hsdsizec,
         partner_birth_country = brthpcan,
         partner_birth_province = brtpprvc,
         partner_vis_minority = visminpr,
         partner_sex = rsh_125a,
         partner_education = eop_200,
         average_hours_worked = uhw_16gr,
         worked_last_week = lmam_01,
         partner_main_activity = acmpryr,
         self_rated_health = srh_110,
         self_rated_mental_health = srh_115,
         religion_has_affiliation = religflg,
         regilion_importance = rlr_110,
         language_home = lanhome,
         language_knowledge = lan_01,
         income_family = famincg2,
         income_respondent = ttlincg2,
         occupation = noc1610,
         childcare_regular = cc_20_1,
         childcare_type = cc_30_1,
         childcare_monthly_cost = ccmoc1c,
         ever_fathered_child = cor_031,
         ever_given_birth = cor_041,
         number_of_current_union = cu0rnkc,
         lives_with_partner = pr_cl,
         children_in_household = chh0014c,
         number_total_children_intention = nochricc,
         has_grandchildren = grndpa,
         grandparents_still_living = gparliv,
         ever_married = evermar,
         current_marriage_is_first = ma0_220,
         number_marriages = nmarevrc,
         religion_participation = ree_02,
         partner_location_residence = rsh_131b,
         full_part_time_work = rto_101,
         time_off_work_birth = rto_110,
         reason_no_time_off_birth = rto_120,
         returned_same_job = rtw_300,
         satisfied_time_children = sts_410,
         provide_or_receive_fin_supp = csp_105,
         fin_supp_child_supp = csp_110a,
         fin_supp_child_exp = csp_110b,
         fin_supp_lump = csp_110c,
         fin_supp_other = csp_110d,
         fin_supp_agreement = csp_160,
         future_children_intention = fi_110) 

#### Clean up ####
gss <- gss %>% 
  mutate_at(vars(age:future_children_intention), 
            .funs = funs(ifelse(.=="Valid skip"|.=="Refusal"|.=="Not stated", "NA", .))) 

gss <- gss %>% 
  mutate(is_male = ifelse(sex=="Male", 1, 0)) 

gss <- gss %>% 
  mutate_at(vars(fin_supp_child_supp:fin_supp_other), .funs = funs(case_when(
    .=="Yes"~1,
    .=="No"~0,
    .=="NA"~as.numeric(NA)
  )))

main_act <- raw_data %>% 
  mutate(main_activity = case_when(
    mpl_105a=="Yes"~ "Working at a paid job/business",
    mpl_105b=="Yes" ~ "Looking for paid work",
    mpl_105c=="Yes" ~ "Going to school",
    mpl_105d=="Yes" ~ "Caring for children",
    mpl_105e=="Yes" ~ "Household work", 
    mpl_105i=="Yes" ~ "Other", 
    TRUE~ "NA")) %>% 
  select(main_activity) %>% 
  pull()

age_diff <- raw_data %>% 
  select(marstat, aprcu0c, adfgrma0) %>% 
  mutate_at(.vars = vars(aprcu0c:adfgrma0),
            .funs = funs(eval(parse(text = cw_statements %>%
                                      filter(variable_name==deparse(substitute(.))) %>%
                                      select(cw_statement) %>%
                                      pull())))) %>% 
  mutate(age_diff = ifelse(marstat=="Living common-law", aprcu0c, adfgrma0)) %>% 
  mutate_at(vars(age_diff), .funs = funs(ifelse(.=="Valid skip"|.=="Refusal"|.=="Not stated", "NA", .))) %>% 
  select(age_diff) %>% 
  pull()

gss <- gss %>% mutate(main_activity = main_act, age_diff = age_diff)

# Change some from strings into numbers
gss <- gss %>% 
  rowwise() %>% 
  mutate(hh_size = str_remove(string = hh_size, pattern = "\\ .*")) %>% 
  mutate(hh_size = case_when(
    hh_size=="One" ~ 1,
    hh_size=="Two" ~ 2,
    hh_size=="Three" ~ 3,
    hh_size=="Four" ~ 4,
    hh_size=="Five" ~ 5,
    hh_size=="Six" ~ 6
  )) 

gss <- gss %>% 
  rowwise() %>% 
  mutate(number_marriages = str_remove(string = number_marriages, pattern = "\\ .*")) %>% 
  mutate(number_marriages = case_when(
    number_marriages=="No" ~ 0,
    number_marriages=="One" ~ 1,
    number_marriages=="Two" ~ 2,
    number_marriages=="Three" ~ 3,
    number_marriages=="Four" ~ 4
  )) 

gss <- gss %>% 
  rowwise() %>% 
  mutate(number_total_children_known = ifelse(number_total_children_intention=="Don't know"|number_total_children_intention=="NA", 0, 1)) %>% 
  mutate(number_total_children_intention = str_remove(string = number_total_children_intention, pattern = "\\ .*")) %>% 
  mutate(number_total_children_intention = case_when(
    number_total_children_intention=="None" ~ 0,
    number_total_children_intention=="One" ~ 1,
    number_total_children_intention=="Two" ~ 2,
    number_total_children_intention=="Three" ~ 3,
    number_total_children_intention=="Four" ~ 4,
    number_total_children_intention=="Don't" ~ as.numeric(NA)
  )) 

write_csv(gss, "gss_clean.csv")

```


```{r, include = FALSE}

#### You will need to update/clean the code below based off the variables you want to use in your poststratification.
#get rid of respondents that didn't answer
survey_data1 <- 
  survey_data %>% 
  mutate(age = ifelse(0<= 2019-q2 & 2019-q2 < 25, "Under 25", 
                      ifelse(25<= 2019-q2 & 2019-q2 < 35, "25-34",
                             ifelse(35 <= 2019-q2 & 2019-q2 < 45, "35-44",
                                    ifelse(45<= 2019-q2 & 2019-q2 < 55, "45-54",
                                           ifelse(55 < 2019-q2, "Above 55", NA))))),
         province = ifelse(q4 == 1, "Newfoundland and Labrador", 
                           ifelse(q4 == 2, "Prince Edward Island",
                                  ifelse(q4 == 3, "Nova Scotia", 
                                         ifelse(q4 == 4, "New Brunswick",
                                                ifelse(q4 == 5, "Quebec",
                                                       ifelse(q4 == 6, "Ontario",
                                                              ifelse(q4 == 7, "Manitoba",
                                                                     ifelse(q4 == 8, "Saskatchewan",
                                                                            ifelse(q4 == 9, "Alberta", 
                                                                                   ifelse(q4 == 10, "British Columbia",
                                   NA)))))))))), 
         highest_education = ifelse(1 <= q61 & q61 <= 4, "Less than highschool diploma",
                                    ifelse(q61 == 5 | q61 == 6 | q61 == 8, "Completed highschool or equivalent", 
                                           ifelse(q61 == 7, "Completed technical, community college, CEGEP, College", 
                                                  ifelse(q61 == 9, "Bachelor's Degree", 
                                                         ifelse(q61 == 10 | q61 == 11, "Master's Degree or above", NA))))),
         household_income_before_tax =  ifelse(0 <= q69 & q69 <= 24999, "Less than $25,000",
                                     ifelse(25000 <= q69 & q69 <= 49999, "$25,000 to $49,999",
                                            ifelse(50000 <= q69 & q69 <= 74999, "$50,000 to $74,999",
                                                   ifelse(75000 <= q69 & q69 <= 99999, "$75,000 to $99,999",
                                                        ifelse(100000 <= q69 & q69 <= 124999, "$100,000 to $ 124,999",
                                                              ifelse(125000 >= q69, "$125,000 and more", NA)))))),
         visible_minority = ifelse(q66a_7 == 1 | q66a_11 == 1 | q66a_15 == 1, "Yes", 
                                   ifelse(q66a_2 == 1 | q66a_3 == 1 | q66a_4 == 1 | q66a_5 == 1 | q66a_6 == 1 | q66a_8 == 1 | q66a_9 == 1 | q66a_10 == 1 | q66a_12 == 1 | q66a_13 == 1 |q66a_14 == 1 | q66a_16 == 1, "No", NA)),
         gender = ifelse(q3 == 1, "Male", ifelse(q3 == 2, "Female", NA)),
         vote_liberal = ifelse(q11==1, 1, 0)) %>% 
  select(age, gender, province, highest_education, household_income_before_tax, visible_minority, vote_liberal)

#Get rid of rows with NA
survey_data1 <- na.omit(survey_data1)

#Cleaning Census Data
census_data1 <- census_data %>% 
  mutate(age = ifelse(0<= age & age < 25, "Under 25", 
                      ifelse(25<= age & age < 35, "25-34",
                             ifelse(35 <= age & age < 45, "35-44",
                                    ifelse(45<= age & age < 55, "45-54",
                                           ifelse(55 < age, "Above 55", NA))))), 
         province = province, 
         visible_minority = ifelse(vis_minority == "Not a visible minority", "No", "Yes"),
         household_income_before_tax = income_family,
         highest_education = ifelse(education == "Less than high school diploma or its equivalent" , "Less than highschool diploma",
                                    ifelse(education == "High school diploma or a high school equivalency certificate" | education == "Trade certificate or diploma", "Completed highschool or equivalent",
                                           ifelse(education == "College, CEGEP or other non-university certificate or di..." | education == "University certificate or diploma below the bachelor's level", "Completed technical, community college, CEGEP, College", 
                                                  ifelse(education == "Bachelor's degree (e.g. B.A., B.Sc., LL.B.)" , "Bachelor's Degree",
                                                         ifelse(education == "University certificate, diploma or degree above the bach..." , "Master's Degree or above", NA))))),
         gender = sex)%>% 
  select(age, gender, province, highest_education, household_income_before_tax, visible_minority)

census_data1 <- na.omit(census_data1)

```

### Important Variables
- **age** is a categorical variable that allocates the interviewee's response to 1 of 5 categories: *under 25*, *25-34*, *35-44*, *45-54*, and *above 55*.  
- **gender** is a categorical variable that records the respondent's sex as male or female.
- **province** is a categorical variable that documents the province in which the respondent inhabits. There are 10 provinces recorded in this data-set: *Alberta*, *British Columbia*, *Manitoba*, *New Brunswick*, *Newfoundland & Labrador*, *Nova Scotia*, *Ontario*, *Prince Edward Island*, *Quebec*, and *Saskatchewan*.  
- **highest_education** is a categorical variable that records the respondent's highest level of education attained by degree. It consists of *less than high school diploma*, *completed high school or equivalent*, *completed technical/community college/CEGEP/college*, *bachelor's degree*, and *master's degree or above*. This study will refer to this variable as highest education from this point on-wards.  
- **household_income_before_tax** is a categorical variable that allocates the interviewee's response regarding his/her household income before tax in Canadian dollars to 1 of 6 categories: *less than \$25,000*, *\$25,000-\$49,999*, *\$50,000-\$74,999*, *\$75,000-\$99,999*, *\$100,000-\$124,999*, and *\$125,000 and more*. This study will use household income and household income before tax interchangeably from this point on-wards. 
- **visible_minority** is a categorical variable of binary value that declares whether or not an interviewee categorizes him/herself as a minority. This study will refer to this variable as visible minority from this point on-wards.  
- **vote_liberal1** is the dependent variable in this study. It is a categorical variable that takes on a binary value depending on if the respondent declared a liberal vote or not. From this point on-wards, this study will refer to this variable as vote liberal, liberal vote, or a similar variation. 



```{r, include=FALSE}

survey_data2 <- survey_data1 %>% mutate(vote_liberal1 = as.factor(vote_liberal))
stat1 <- survey_data2 %>% 
  group_by(household_income_before_tax, vote_liberal1) %>% summarise(n=n())

stat2 <- survey_data2 %>% 
  group_by(age, vote_liberal1) %>% summarise(n=n())
  
stat3 <- survey_data2 %>% 
  group_by(province, vote_liberal1) %>% summarise(n=n())

stat4 <- survey_data2 %>% 
  group_by(highest_education, vote_liberal1) %>% summarise(n=n())

stat5 <- survey_data2 %>% 
  group_by(visible_minority, vote_liberal1) %>% summarise(n=n())

stat6 <- survey_data2 %>% 
  group_by(gender, vote_liberal1) %>% summarise(n=n())

stat7 <- survey_data2 %>% group_by(vote_liberal1)%>% summarise(n=n())

stat8 <- census_data1 %>% group_by(age)%>% summarise(n=n())

stat8 <- stat8 %>% mutate(percent = n/20139)

stat9 <- census_data1 %>% group_by(gender)%>% summarise(n=n())

stat9 <- stat9 %>% mutate(percent = n/20139)


stat10 <- census_data1 %>% group_by(visible_minority)%>% summarise(n=n())

stat10 <- stat10 %>% mutate(percent = n/20139)


stat11 <- census_data1 %>% group_by(province)%>% summarise(n=n())

stat11 <- stat11 %>% mutate(percent = n/20139)

stat12 <- census_data1 %>% group_by(household_income_before_tax)%>% summarise(n=n())

stat12 <- stat12 %>% mutate(percent = n/20139)


stat13 <- census_data1 %>% group_by(highest_education)%>% summarise(n=n())

stat13 <- stat13 %>% mutate(percent = n/20139)

```



### Data Summaries
The figures in the following section are visual representations of the CES 2019 data-set. 
<p>&nbsp;</p>
```{r, echo = FALSE}
#Graphical Summaries: Figure 1
stat1 %>% ggplot() +
  geom_bar(aes(y = n, x = household_income_before_tax, fill = vote_liberal1), stat="identity",
           position='stack') + 
  theme(axis.text.x = element_text(face = "bold", 
                           size=5, angle=45)) +
  scale_x_discrete(name ="Household Income Level", 
                    limits=c("Less than $25,000","$25,000 to $49,999","$50,000 to $74,999", "$75,000 to $99,999", "$100,000 to $ 124,999", "$125,000 and more")) +
  scale_y_discrete(name ="Count") +
    scale_fill_discrete("Would Vote Liberal", 
                      labels=c("No", "Yes")) +
ggtitle("Liberal Vote Distribution based on Household Income Level (Survey)")
```
Above, Figure 1 shows the distribution of liberal votes based on household income before tax. The most reported income level before tax is the *\$125,000 and more* category. Referring to Table 1, 30.2% of respondents reported the aforementioned income level. It also holds the highest percentage of respondents that would not vote liberal, 81%. The second most reported income level is the *\$50,000-\$49,999* category. 17.8% of interviewees fall into this category. 22.4% of these respondents would vote for the liberal party. The income category with the highest recorded liberal votes is *\$75,000-\$99,999* with 25.9%. However, this income category only makes up  of 13.3% of responses. 
 
<p>&nbsp;</p>

Figure 2 (refer to appendix) shows the distribution of liberal votes over age group. Without analyzing any numerical summaries, we see from the graph that the *above 55* age group has the most reported votes against the liberal party. It is also the age group that captures majority of the interviewees. Referring to Table 1, the *above 55* category makes up 53% of the responses recorded and reports a 76% vote against the liberal party. On the other hand, the least common age group is *under 25*. It consists of only 6.6% of the responses recorded and has a 18% voting rate for liberals.  
```{r, echo = FALSE}
#Graphical Summaries: Figure 3
stat3 %>% ggplot() +
  geom_bar(aes(y = n, x = province, fill = vote_liberal1), stat="identity",
           position='stack') + 
  theme(axis.text.x = element_text(face = "bold", 
                           size=5, angle= 45)) +
  scale_x_discrete(name ="Province" 
                    ) +
  scale_y_discrete(name ="Count") +
    scale_fill_discrete("Would Vote Liberal", 
                      labels=c("No", "Yes")) +
ggtitle("Liberal Vote Distribution based on Province (Survey)")
```
Figure 3 shows the distribution of liberal vote by province. Table 1 shows that *Ontario* is the most reported province making up 16.2% of the responses. The liberal vote distribution is 33.2% to 66.8%. In comparison to the other provinces, *Ontario* has the highest liberal voting turnout. On the contrary, the province with the lowest liberal vote percentage is *Alberta*. *Alberta* contributes 7.1% to the distribution of responses in terms of province. Its liberal vote ratio is 8.7% to 91.3%. 

```{r, echo = FALSE}
#Graphical Summaries: Figure 5
stat5 %>% ggplot() +
  geom_bar(aes(y = n, x = visible_minority, fill = vote_liberal1), stat="identity",
           position='stack') + 
  theme(axis.text.x = element_text(face = "bold", 
                           size=10)) +
  scale_x_discrete(name ="Visible Minority" 
                  ) +
  scale_y_discrete(name ="Count") +
    scale_fill_discrete("Would Vote Liberal", 
                      labels=c("No", "Yes")) +
ggtitle("Liberal Vote Distribution based on Visible Minority Status (Survey)")
```
Figure 5 shows the distribution of liberal vote over whether or not the respondent considers him/herself a minority. According Table 1, 89.6% of interviewees responded *no* and 10.4% *yes*.  21.6% of those who do not consider themselves minority responded with a liberal vote and 18.9% of those who do consider themselves minority responded with a liberal vote. 

```{r, include = FALSE}
#Graphical Summaries: Figure 4
stat4 %>% ggplot() +
  geom_bar(aes(y = n, x = highest_education, fill = vote_liberal1), stat="identity",
           position='stack') + 
  theme(axis.text.x = element_text(face = "bold", 
                           size=5, angle= 90)) +
  scale_x_discrete(name ="Highest Education" ,
                    limits=c("Less than highschool diploma", "Completed highschool or equivalent", "Completed technical, community college, CEGEP, College",  "Bachelor's Degree", "Master's Degree or above")) +
  scale_y_discrete(name ="Count") +
    scale_fill_discrete("Would Vote Liberal", 
                      labels=c("No", "Yes")) +
ggtitle("Liberal Vote Distribution based on Education (Survey)")

#Graphical Summaries: Figure 6
stat6 %>% ggplot() +
  geom_bar(aes(y = n, x = gender, fill = vote_liberal1), stat="identity",
           position='stack') + 
  theme(axis.text.x = element_text(face = "bold", 
                           size=10)) +
  scale_x_discrete(name ="Gender" 
                  ) +
  scale_y_discrete(name ="Count") +
    scale_fill_discrete("Would Vote Liberal", 
                      labels=c("No", "Yes")) +
ggtitle("Liberal Vote Distribution based on Gender (Survey)")

#Distribution tables for ces2019 and gss
library(kableExtra)
ces_table <- matrix(c("Under 25", "25-34" , "35-44" , "45-55", "Above 55"," ", " ", " ", " "," ",  6.56 , 14.3 ,12.5 , 13.5 , 53, " ", " "," ", " "," ", "Male" , "Female", " ", " ", " "," ", " ", " ", " ", " ", 57.3, 42.7, " "," ", " ", " "," "," "," ", " ","No", "Yes", " "," ", " ", " "," "," ", " ", " ", 89.6, 10.4, " ", " "," "," "," "," ", " ", " ", "AB" , "BC" , "MB" , "NB" , "NL", "NS" , "ON" , "PE", "QC" , "SA", 7.1, 17.9, 6.4, 5, 5.3, 5.3, 16.2, 6.4, 22.4, 6.9, "Less than $25,000" , "$25,000 to $49,999" , "$50,000 to $74,999" ,"$75,000 to $99,999", "$100,000 to $124,999", "$125,000 and more",  " ", " "," "," ", 11, 15.8, 17.8, 13.3, 12, 30.2," ", " ", " "," ", "Less than highschool diploma", "Completed highschool or equivalent", "Completed technical, community college, CEGEP, College", "Bachelor's Degree", "Master's Degree or above", " ", " " ," "," ", " ", 8, 31.9, 23, 23.4, 13.6, " ", " ", " ", " "," ", "No", "Yes"," "," ", " ", " "," "," ", " ", " ", 78.7, 21.3," "," ", " ", " "," "," ", " ", " "),nrow=14, ncol= 10,byrow=TRUE)
rownames(ces_table) <- c("Age Group", "Percentages","Gender", "Percentages", "Visible Minority", "Percentages", "Province", "Percentages", "Houshold Income", "Percentages", "Highest Education", "Percentages", "Vote Liberal", "Percentages")
kbl(ces_table, booktabs = T) %>%
  kable_styling(latex_options = c("striped", "scale_down")) %>% 
   footnote(general = "Number of Effective Respondents is 1629")
```

\newpage
```{r, echo=FALSE}
kbl(ces_table, booktabs = T) %>%
  kable_styling(latex_options = c("striped", "scale_down")) %>% 
   footnote(general = "Table 1","Number of Effective Respondents is 1629")
```


```{r, echo = FALSE}
gss_table <- matrix(c("Under 25", "25-34" , "35-44" , "45-55", "Above 55"," ", " ", " ", " "," ",  7.4 , 13.6 ,15.6 , 14.9 , 48.5, " ", " "," ", " "," ", "Male" , "Female", " ", " ", " "," ", " ", " ", " ", " ", 45.6, 54.4, " "," ", " ", " "," "," "," ", " ","No", "Yes", " "," ", " ", " "," "," ", " ", " ", 86, 14, " ", " "," "," "," "," ", " ", " ", "AB" , "BC" , "MB" , "NB" , "NL", "NS" , "ON" , "PE", "QC" , "SA", 8.4, 12.2, 5.8, 6.5, 5.3, 6.9, 27.3, 3.4, 18.6, 5.6, "Less than $25,000" , "$25,000 to $49,999", "$50,000 to $74,999" ,"$75,000 to $99,999", "$100,000 to $124,999", "$125,000 and more",  " ", " "," "," ", 13.4, 21.1, 17.9, 14.2, 10.5, 22.9," ", " ", " "," ", "Less than highschool diploma", "Completed highschool or equivalent", "Completed technical, community college, CEGEP, College", "Bachelor's Degree", "Master's Degree or above", " ", " " ," "," ", " ", 15, 31.2, 26.1, 18.5, 9.1, " ", " ", " ", " "," "),nrow=12, ncol= 10,byrow=TRUE)
rownames(gss_table) <- c("Age Group", "Percentages","Gender", "Percentages", "Visible Minority", "Percentages", "Province", "Percentages", "Houshold Income", "Percentages", "Highest Education", "Percentages")
kbl(gss_table, booktabs = T) %>%
  kable_styling(latex_options = c("striped", "scale_down")) %>%
  footnote(general = "Table 2","Number of Effective Respondents is 20139")

```
Table 1 shows the percentage of responses per category per variable in the CES data. The majority of interviewees responded *above 55* in age,  *male*, *no* to whether or not they consider themselves of visible minority, live in *Ontario*, have a household income before tax of *\$125,000 and more*, *completed high school or equivalent* in terms of highest education attained, and said *no* to vote liberal. 

Table 2 shows the percentage of responses per category per variable in the GSS data. The majority of interviewees responded *above 55* in age, *female*, *no* to whether or not they consider themselves of visible minority, live in *Ontario*, have a household income before tax of *\$125,000 and more*, and *completed high school or equivalent* in terms of highest education attained. There is no percent of respondents that would vote liberal as that is what this study is attempting to predict. 

Comparing the two distribution of responses, the only difference in majority is gender. The GSS data distribution shows 54.4% of interviewees were female and 45.6% male. The CES data distribution shows 42.7% female and 57.3% male.


## Methods
As the goal of this analysis is to predict whether or not the liberal party will continue to be the ruling party in Canada, the dependent variable must be a binary variable. Therefore, the methodology used is a multilevel multiple logistic regression model. Poststratification of the model estimates is then used to predict the overall popular vote of the next Canadian federal election. Further information regarding the regression model and poststratification is included in their respective sections below.  

### Model Specifics
This study will use a multilevel multiple logistic regression model to model the probability of the liberal party winning the next Canadian federal election. The variables taken into account to model the probability of voting for the liberal party are: age, gender, province, highest education, visible minority and household income before tax. The aforementioned variables are all categorical variables. This model was chosen purely based on rational justification. Multilevel regression models are used when there is a hierarchical structure in the data [17]. It is beneficial when it is predicted that there will be group effects [17]. In this study, the multilevel regression will be done for household income before tax. The multilevel multiple logistic regression used is: 

**Level 1:**
$$ y = \beta_0+\beta_1  x_{age} +\beta_2 x_{gen} + \beta_3 x_{prov}+\beta_4 x_{educ}+\beta_5 x_{min}+\beta_6 x_{inc} + r$$
**Level 2:**
$$\beta_0 = r_{00}+r_{06}+W+u_0$$

Where $y$ represents the probability of the liberal party winning the next Canadian federal election, $\beta_0$ represents the y-intercept of the regression model, $\beta_1$ is the effect of age on $y$, $\beta_2$ is the effect of gender on $y$, $\beta_3$ is the effect of province on $y$, $\beta_4$ is the effect of highest education attained on $y$, $\beta_5$ is the effect of visual minority on $y$, $\beta_6$ is the effect of household income before tax on $y$.

```{r, include=FALSE}
library(lme4)
# Creating the Multilevel Multiple Logistic Regression Model
model <- glmer(vote_liberal ~ age + gender + province + highest_education + as.factor(visible_minority) + (1 | household_income_before_tax), data = survey_data1, family=binomial)

summary(model)
# OR
# broom::tidy(model)

### Don't show the results/output here...

#model is the multilevel regression

```


## Post-Stratification 

In order to estimate the proportion of voters who voted liberal for each independent variable namely; the age group, gender, highest education, provinces, visible minority, and household income level, adjusted to the census demographic statistics post-stratification was done using the following mathematical formula.   


$$ \hat{y}^{ps}=\frac{\sum{N_j\hat{y}_j}}{\sum{N_j}} $$
Where $\hat{y}_j$ is the estimate in each cell and $N_j$ is the population size of the $j^{th}$ cell based off demographics. 

All analysis for this report was programmed using `R version 4.0.2`. 



## Results 

```{r, include=FALSE}

# Creating the Model


# Model Results (to Report in Results section)
# summary(model)
# OR
# broom::tidy(model)
```

```{r, include=FALSE}

# Here I will perform the post-stratification calculation
census_data_counts <- census_data1 %>% 
  group_by(age, gender, province, highest_education, household_income_before_tax, visible_minority) %>% 
  summarise(n=n())

census_data_counts$estimate <-
  model %>%
 predict(newdata = census_data_counts, type = "response")

yps_income <- census_data_counts %>% 
  mutate(liberal_predict_prop = estimate*n) %>%
   group_by(household_income_before_tax) %>%
  summarise(liberal_predict = sum(liberal_predict_prop)/sum(n))

yps_age <- census_data_counts %>% 
  mutate(liberal_predict_prop = estimate*n) %>%
   group_by(age) %>%
  summarise(liberal_predict = sum(liberal_predict_prop)/sum(n))

yps_gender <- census_data_counts %>% 
  mutate(liberal_predict_prop = estimate*n) %>%
   group_by(gender) %>%
  summarise(liberal_predict = sum(liberal_predict_prop)/sum(n))

yps_province <- census_data_counts %>% 
  mutate(liberal_predict_prop = estimate*n) %>%
   group_by(province) %>%
  summarise(liberal_predict = sum(liberal_predict_prop)/sum(n))

yps_education <- census_data_counts %>% 
  mutate(liberal_predict_prop = estimate*n) %>%
   group_by(highest_education) %>%
  summarise(liberal_predict = sum(liberal_predict_prop)/sum(n))

yps_minority <- census_data_counts %>% 
  mutate(liberal_predict_prop = estimate*n) %>%
   group_by(visible_minority) %>%
  summarise(liberal_predict = sum(liberal_predict_prop)/sum(n))

yps_all <- census_data_counts %>% 
  mutate(liberal_predict_prop = estimate*n) %>%
   group_by(age, gender, province, highest_education, household_income_before_tax, visible_minority) %>%
  summarise(liberal_predict = sum(liberal_predict_prop)/sum(n))
```

Post-Stratification Table for different Age Groups 
```{r, echo= FALSE}
#YPS TABLES
colnames(yps_age) <- c("Age", "Liberal Votes Prediction")
kbl(yps_age)
```
This table shows the $\hat{y}^{ps}$ for the percentage that one would vote for the liberals in different age groups.
<p>&nbsp;</p>
<p>&nbsp;</p>

Post-Stratification Table on different Highest Education 
```{r, echo= FALSE}
colnames(yps_education) <- c("Highest Education", "Liberal Votes Prediction")
kbl(yps_education)
```
This table shows the $Y^{ps}$ for the percentage that one would vote for the liberals from different highest education groups.

<p>&nbsp;</p>
<p>&nbsp;</p>

Post-Stratification Table on different Gender
```{r, echo= FALSE}
colnames(yps_gender) <- c("Gender", "Liberal Votes Prediction")
kbl(yps_gender)
```
This table shows the $Y^{ps}$ for the percentage that one would vote for the liberals from different genders.

<p>&nbsp;</p>
<p>&nbsp;</p>

Post-Stratification Table on different Household Income Level
```{r, echo= FALSE}
colnames(yps_income) <- c("Household Income Level", "Liberal Votes Prediction")
kbl(yps_income)
```
This table shows the $Y^{ps}$ for the percentage that one would vote for the liberals from different household income levels.

<p>&nbsp;</p>
<p>&nbsp;</p>

Post-Stratification Table on Visible Minority
```{r, echo= FALSE}
colnames(yps_minority) <- c("Visible Minority", "Liberal Votes Prediction")
kbl(yps_minority)
```
This table shows the $Y^{ps}$ for the percentage that one would vote for the liberals depending on visible minority.

<p>&nbsp;</p>
<p>&nbsp;</p>

Post-Stratification Table on Provinces
```{r, echo= FALSE}
colnames(yps_province) <- c("Province", "Liberal Votes Prediction")
kbl(yps_province)
```
This table shows the $Y^{ps}$ for the percentage that one would vote for the liberals depending on province.
<p>&nbsp;</p>
<p>&nbsp;</p>



For Income, we can see that the population who's income is greater than \$50,000 would more likely vote for the Liberals than the population who has an income less than $50,000.

For age, we can see that there is a variance. The population that is over 55 years old and the population of 35-44 years old are more likely to vote for the Liberals, than all other age groups.

For Gender, we can see that the female population are more likely to vote for the Liberals, with a value of 22% while the male population is at around 20%.

For Province, the provinces that are most likely to vote for the Liberals are Ontario; with a 30%, PEI; with 27%, and Newfoundland and Labrador; with 27%.

Finally for Education, the population who has a Bachelor's degree or higher are more likely to vote for the liberals than the population that does not have a Bachelor's degree or higher.

We had another group that included all the variables in one group but we decided not to include it because there was too much data and it would make the report over 70 pages long.

Even though the overall percentage of the population to vote for the Liberals was lower than expected, the percentages from each groups still made sense, since typically, the white collared population who lives in urban areas rather than blue collared population who lives in rural areas would more likely to vote for the Liberals than other parties.


```{r, include = FALSE}

# Here you can include some relevant visualizations.


```


## Conclusions

For this report, we used statistical methods and post-stratification to predict the overall popular vote of the next Canadian Federal Election. In the introduction section, we introduced our hypothesis: 
**The Liberals will continue to be in power in the next Canadian election.**
To test our hypothesis, our main methodology included Multi-level Multiple Logistic Regression and Post-Stratification.

Using Post-Stratification, we have multiple factors: **Income**, **Age**, **Gender**, **Province**, **Education**, and **Minority**.
Using the predicted data that we calculated in the above section, we can conclude that the overall percentage of the population to vote for the Liberals was lower than expected, the percentages from each groups still made sense. 
All in all, the percentage of population that will vote for the Liberals is around 20% which is sigificantly less than we expected as Justin Trudeau won with 31.5% of the votes in the 2021 Election [11]. Therefore, based on the predicted data we calculated, **we will reject our hypotheses and conclude that the Liberals will not lose the next Federal Election and will not maintain power in Government.**

Overall, this analysis can be a good starting point to predict the election winners in the next Federal Election. We can hypothesis using data and statistical models and prepare for the next government. The political parties can also benefit from this analysis because they can see which parts of the population they would want to focus more on campaigning to boost the votes.

Some limitations that we faced are that there were too many variables in our model so we spent a lot of time trying to interpret the model. Next time, a simplier model might have sufficed.

This analysis can be easily reproduced using the next election's dataset. For example, we used the 2019 election dataset to predict the next federal election winners. When the 2021 election dataset comes out it might be better to use the most recent one because it might give more accurate results.

Every four years, or when the Prime Minister decides to call the election early, Canadians are called to the voting stand to vote for their choice for Canada's next government. Justin Trudeau's Liberal Party has been in power for almost a decade, as other major political parties of Canada try be Canada's next government. This analysis used multi-level multiple logistic regression and post-stratification to predict the next winner of the Federal Election and from the analysis and research, it is predicted that the Liberal party will not maintain power as Canada's Government.

## Appendix
Figure 2
```{r, echo = FALSE}
#Graphical Summaries: Figure 2
stat2 %>% ggplot() +
  geom_bar(aes(y = n, x = age, fill = vote_liberal1), stat="identity",
           position='stack') + 
  theme(axis.text.x = element_text(face = "bold", 
                           size=5,)) +
  scale_x_discrete(name ="Age Group", 
                    limits=c("Under 25","25-34","35-44", "Above 55")) +
  scale_y_discrete(name ="Count") +
    scale_fill_discrete("Would Vote Liberal", 
                      labels=c("No", "Yes")) +
ggtitle("Liberal Vote Distribution based on Age Group (Survey)")
```
Figure 4
```{r, echo = FALSE}
#Graphical Summaries: Figure 4
stat4 %>% ggplot() +
  geom_bar(aes(y = n, x = highest_education, fill = vote_liberal1), stat="identity",
           position='stack') + 
  theme(axis.text.x = element_text(face = "bold", 
                           size=5, angle= 90)) +
  scale_x_discrete(name ="Highest Education" ,
                    limits=c("Less than highschool diploma", "Completed highschool or equivalent", "Completed technical, community college, CEGEP, College",  "Bachelor's Degree", "Master's Degree or above")) +
  scale_y_discrete(name ="Count") +
    scale_fill_discrete("Would Vote Liberal", 
                      labels=c("No", "Yes")) +
ggtitle("Liberal Vote Distribution based on Education (Survey)")
```
<p>&nbsp;</p>
<p>&nbsp;</p>

Figure 6
```{r, echo = FALSE}
#Graphical Summaries: Figure 6
stat6 %>% ggplot() +
  geom_bar(aes(y = n, x = gender, fill = vote_liberal1), stat="identity",
           position='stack') + 
  theme(axis.text.x = element_text(face = "bold", 
                           size=10)) +
  scale_x_discrete(name ="Gender" 
                  ) +
  scale_y_discrete(name ="Count") +
    scale_fill_discrete("Would Vote Liberal", 
                      labels=c("No", "Yes")) +
ggtitle("Liberal Vote Distribution based on Gender (Survey)")
```


## Bibliography

1. Grolemund, G. (2014, July 16) *Introduction to R Markdown*. RStudio. [https://rmarkdown.rstudio.com/articles_intro.html](https://rmarkdown.rstudio.com/articles_intro.html). ((Last Accessed: November 6, 2021) 

2. Dekking, F. M., et al. (2005) *A Modern Introduction to Probability and Statistics: Understanding why and how.* Springer Science & Business Media.

3.  Allaire, J.J., et. el. *References: Introduction to R Markdown*. RStudio. [https://rmarkdown.rstudio.com/docs/](https://rmarkdown.rstudio.com/docs/). ((Last Accessed: November 6, 2021) 

4. Wickham, H., et. al.  *Tidyverse*. from [https://tidyverse.org/]( https://tidyverse.org/).  ((Last Accessed: November 6, 2021) 

5. Wickham, H., et. al. *Create Elegant Data Visualisations Using the Grammar of Graphics ggplot2*. from [https://ggplot2.tidyverse.org/](https://ggplot2.tidyverse.org/).  ((Last Accessed: November 6, 2021) 

6. Gibbs , A., &amp; Stringer, A. (2021, January 20). *Probability, statistics, and data analysis - GitHub Pages. GitHub.*, from [https://awstringer1.github.io/sta238-book/](https://awstringer1.github.io/sta238-book/).  ((Last Accessed: November 6, 2021) 

7. Zhu, H. (2021, February 19). *KableR Package. Create awesome HTML table with knitr::kable and kableextra.*, from [https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html). (Last Accessed: November 6, 2021) 

8. Statistics Canada. (2020, April). *General Social Survey.* Ottawa; Canada.

9. Stephenson, L. B., Loewen, P. J., Rubenson, D., &amp; Harrel, A. (2020, August 11). *Canadian Election Study, 2019 Phone Survey.* Canada; Canada. 

10. Canada, E. (n.d.). Home.  Elections Canada. Retrieved November 4, 2021, from https://www.elections.ca/content.aspx?section=res&amp;dir=ces&amp;document=part1&amp;lang=e. 

11. CBC/Radio Canada. (2019, October 25). Opinion | do the math - Canada's election system is misrepresenting the will of the people: Opinion | CBC news. CBCnews. Retrieved November 4, 2021, from https://www.cbc.ca/news/opinion/opinion-warren-bowen-electoral-change-1.5333743. 
12. CBC/Radio Canada. (n.d.). CBC News Canada poll tracker. CBCnews. Retrieved November 8, 2021, from https://newsinteractives.cbc.ca/elections/poll-tracker/canada/. 

13. CBC/Radio Canada. (n.d.). Federal election 2021 live results. CBCnews. Retrieved November 3, 2021, from https://newsinteractives.cbc.ca/elections/federal/2021/results/. 

14. Government of Canada, S. C. (2017, February 27). The General Social Survey: An overview. Government of Canada, Statistics Canada. Retrieved November 4, 2021, from https://www150.statcan.gc.ca/n1/pub/89f0115x/89f0115x2013001-eng.htm. 

15. Heard, A. (n.d.). Canadian election results by party 1867 to 2019. Canadian Election Results: 1867-2019. Retrieved November 4, 2021, from https://www.sfu.ca/~aheard/elections/1867-present.html. 

16. International, R. C. (2020, May 26). Majority or minority government. Canadian Politics. Retrieved November 4, 2021, from https://www.rcinet.ca/politique-canadienne-en/2015/11/09/majority-or-minority-government/. 

17. University of Bristol. (2017, September 19). What are multilevel models and why should I use them? What are multilevel models and why should I use them? | Centre for Multilevel Modelling | University of Bristol. Retrieved November 9, 2021, from http://www.bristol.ac.uk/cmm/learning/multilevel-models/what-why.html. 